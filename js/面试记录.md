### js实现一个持续动画

```
var e = document.getElementById('e')
var falg = true;
var left = 0;
setInterval(() => {
    left == 0 ? falg = true : left == 100 ? falg = false : ''
    falg ? e.style.left = ` ${left++}px` : e.style.left = ` ${left--}px`
}, 1000 / 60)

二
window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame    ||
          function(callback){
            window.setTimeout(callback, 1000 / 60);
          };
})();

var e = document.getElementById("e");
var flag = true;
var left = 0;

function render() {
    left == 0 ? flag = true : left == 100 ? flag = false : '';
    flag ? e.style.left = ` ${left++}px` :
        e.style.left = ` ${left--}px`;
}

(function animloop() {
    render();
    requestAnimFrame(animloop);
})();
```

### js 统计一个字符串出现频率最高的字母/数字

```
      let str = 'asdfghjklaqwertyuiopiaia';

const strChar = str => {

let string = [...str],

maxValue = '',

      obj = {},

        max = 0;

    string.map(value => {

        obj[value] = obj[value] == undefined ? 1 : obj[value] + 1

        if (obj[value] > max) {

            max = obj[value]

            maxValue = value

        }

    })

return maxValue;

}

console.log(strChar(str))    // a



```

### 冒泡排序

```
et arr = [43, 32, 1, 5, 9, 22];
const sort = arr => {
    let res = []
    let temp
    arr.map((v, i) => {
        for (var j = i + 1; j < arr.length; j++) {
           if (arr[i] > arr[j]) {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    })
    return arr
}
console.log(sort(arr))  // [1, 5, 9, 22, 32, 43]；
```

### 数组中的最大差值

```
let arr = [23, 4, 5, 2, 4, 5, 6, 6, 71, -3];
const difference = arr => {
    let min = arr[0],
        max = 0;
    arr.map(value => {
       if (value < min) min = value
        if (value > max) max = value
    })
    return max - min ;
}
console.log(difference(arr))  // 74
```

### 返回元素出现的位置

```
var indices = [];
var array = ['a', 'b', 'a', 'c', 'a', 'd'];
var element = 'a';
//判断元素在不在数组里面
var idx = array.indexOf(element);
//如果元素在数组里面，就循环
while (idx != -1) {
  //把索引推入新数组中
  indices.push(idx);
  //从找到元素的下一个索引开始继续查找
  idx = array.indexOf(element, idx + 1);
}
console.log(indices);
// [0, 2, 4]
```

### 对比两个值是否相等：

console.log(Object.is(NaN,NaN));

### 类的定义

```
class Parent {
    constructor(name) {
        this.name = name;
    }
    getName(){
        return this.name
    }
}
let p = new Parent('zfpx');
console.log(p.getName())
```

### 静态属性通过类来调用

```
class Parent {
    constructor(name) {
        this.name = name;
        return {}
    }
    static a() {
        console.log('abc')
    }
    getName() {
        return this.name
    }
}
Parent.a();
```

### 类的继承

```
class Parent {
    constructor(name) {
        this.name = name;
    }
    static a() {
        console.log('abc')
    }
    getName() {
        return this.name
    }
}
class Child extends Parent {
    constructor(name, age) {
        super(name);
        this.age = age
    }
    getAge() {
        return this.age
    }
}
let c = new Child('zfpx','9');
console.log(c.getName())
```

### js实现trim清除空格

	function trim(str){	
	  return str.replace(/^\s*|\s*$/g,'');
	}

### new操作符具体干了什么？

（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。

（2）属性和方法被加入到 this 引用的对象中。

（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。

### 闭包

```
闭包就是能够读取其他函数内部变量的函数。
function a(x){
       var tem=3;
      function b(y){
          console.log(x+y+(++tem));
     }
}
for(var i=0;i<10;i++){

	(function(i){

	alert(i);

})(i)

}

```

### 程序输出

```
function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      return fun(m,n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);
var b = fun(0).fun(1).fun(2).fun(3);
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);

//a: undefined,0,0,0
//b: undefined,0,1,2
//c: undefined,0,1,1
```

```
function fn() {
    this.a = 0;
    this.b = function() {
        alert(this.a)
    }
}
fn.prototype = {
    b: function() {
        this.a = 20;
        alert(this.a);
    },
    c: function() {
        this.a = 30;
        alert(this.a);
    }
}
var myfn = new fn();
myfn.b();
myfn.c();
```

### 统计字符串字母最多的字母

```
var str = "aaaabbbccccddfgh";
var obj  = {};
for(var i=0;i<str.length;i++){
    var v = str.charAt(i);
    if(obj[v] && obj[v].value == v){
        obj[v].count = ++ obj[v].count;
    }else{
        obj[v] = {};
        obj[v].count = 1;
        obj[v].value = v;
    }
}
for(key in obj){
    document.write(obj[key].value +'='+obj[key].count+'&nbsp;'); // a=4  b=3  c=4  d=2  f=1  g=1  h=1 
}  
```

### 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制。

```
function clone(obj) {
    var o;
    switch (typeof obj) {
        case "undefined":
            break;
        case "string":
            o = obj + "";
            break;
        case "number":
            o = obj - 0;
            break;
        case "boolean":
            o = obj;
            break;
        case "object": // object 分为两种情况 对象（Object）或数组（Array）
            if (obj === null) {
                o = null;
            } else {
                if (Object.prototype.toString.call(obj).slice(8, -1) === "Array") {
                    o = [];
                    for (var i = 0; i < obj.length; i++) {
                        o.push(clone(obj[i]));
                    }
                } else {
                    o = {};
                    for (var k in obj) {
                        o[k] = clone(obj[k]);
                    }
                }
            }
            break;
        default:
            o = obj;
            break;
    }
    return o;
}
```

### 编写一个b继承a的方法

```
function A(name){
    this.name = name;
    this.sayHello = function(){alert(this.name+” say Hello!”);};
}
function B(name,id){
    this.temp = A;
    this.temp(name);        //相当于new A();
    delete this.temp;       
     this.id = id;   
    this.checkId = function(ID){alert(this.id==ID)};
}
```

### 去重

```
let set = new Set([9,2,2,3,1,1]),
    array = [...set];
 console.log(array) //  9 2 3 1 
 
 二、
 function unique1(array) {
    var n = [];
    //一个新的临时数组
    //遍历当前数组 
    for (var i = 0; i < array.length; i++) {
        //如果当前数组的第i已经保存进了临时数组，那么跳过，
        //否则把当前项push到临时数组里面 
        if (n.indexOf(array[i]) == -1) n.push(array[i]);
    };
    return n;
};
```

###正则表达

1、var patt1=new RegExp("e");

document.write(patt1.test("The best things in life are free"));   //true

2、var patt1=new RegExp("e");

 document.write(patt1.exec("The best things in life are free"));   //e

3、secrch：返回匹配成功的索引

```
'abc'.search(/abc/) // 0
'abc'.search(/c/) // 2
```

### 计算元素出现次数

```
var reg = /a/g
var str = 'abcabcabcabcabc'
var num = 0;
var match = null;
while((match = reg.exec(str)) !== null) {
    num++
}
console.log(num) // 5
```

### js千分位分割

```
  var commafy = (num) => {
        return num && num.toString().replace(/(^|\s)\d+/g, (m) => m.replace(/(?=(?!\b)(\d{3})+$)/g, ','))
    }
```

### this、原型、原型链、继承和引用

```
function Parent() {
  this.a = 1;
  this.b = [1, 2, this.a];
  this.c = { demo: 5 };
  this.show = function () {
    console.log(this.a , this.b , this.c.demo );
  }
}
function Child() {
  this.a = 2;
  this.change = function () {
    this.b.push(this.a);
    this.a = this.b.length;
    this.c.demo = this.a++;
  }
}
Child.prototype = new Parent(); 
var parent = new Parent();
var child1 = new Child();
var child2 = new Child();
child1.a = 11;
child2.a = 12;
parent.show();//1 [1, 2, 1] 5
child1.show();//11 [1, 2, 1] 5
child2.show();//12 [1, 2, 1] 5
child1.change();
child2.change();
parent.show();//1 [1, 2, 1] 5
child1.show();//5 [1, 2, 1, 11, 12] 5
child2.show();//6 [1, 2, 1, 11, 12] 5
```

### promise

- pending: 初始状态, 非 fulfilled 或 rejected.
- fulfilled: 成功的操作.
- rejected: 失败的操作.

```
var promise = new Promise((resolve,reject) => {
    if (操作成功) {
        resolve(value)
    } else {
        reject(error)
    }
})
promise.then(function (value) {
    // success
},function (value) {
    // failure
})
```

### 比较typeof与instanceof？

相同点：JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。

typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。

细节：

(1)、typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。

(2)、typeof 来获取一个变量是否存在，如 if(typeof a!="undefined"){alert("ok")}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。

(3)、对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。

Instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例。













